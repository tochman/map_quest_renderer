<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map Animation</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Special Elite', 'Courier New', monospace;
            overflow: hidden;
        }
        #map {
            width: 100%;
            height: 100vh;
            position: relative;
        }
        .leaflet-container {
            background: #e8dcc7;
            /* Vintage map styling */
            filter: sepia(0.4) saturate(0.6) contrast(1.15) brightness(1.05);
        }
        
        /* Make map tiles look aged */
        .leaflet-tile {
            filter: contrast(0.95) brightness(1.1);
            opacity: 0.95 !important;
        }
        
        /* Parchment texture overlay */
        #parchment-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(139, 90, 43, 0.03) 2px, rgba(139, 90, 43, 0.03) 4px),
                repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(139, 90, 43, 0.03) 2px, rgba(139, 90, 43, 0.03) 4px);
            background-color: rgba(244, 232, 208, 0.4);
            pointer-events: none;
            z-index: 1000;
            mix-blend-mode: multiply;
        }
        
        /* Compass rose */
        #compass {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 100px;
            height: 100px;
            z-index: 1001;
            opacity: 0.9;
            filter: drop-shadow(4px 4px 8px rgba(0,0,0,0.4));
        }
        
        /* Date stamp */
        #date-stamp {
            position: absolute;
            top: 30px;
            left: 30px;
            font-family: 'Special Elite', 'Courier New', monospace;
            font-size: 24px;
            color: #3d2817;
            background: rgba(244, 232, 208, 0.9);
            padding: 15px 25px;
            border: 3px solid #8B4513;
            box-shadow: 3px 3px 10px rgba(0,0,0,0.3);
            z-index: 1001;
            transform: rotate(-2deg);
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        /* Centered title card */
        #title-card {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Special Elite', 'Courier New', monospace;
            color: #3d2817;
            background: rgba(244, 232, 208, 0.95);
            padding: 40px 60px;
            border: 4px solid #8B4513;
            box-shadow: 5px 5px 20px rgba(0,0,0,0.5);
            z-index: 2000;
            text-align: center;
            opacity: 0;
            transition: opacity 1s;
            max-width: 800px;
        }
        #title-card .title-text {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 15px;
            line-height: 1.2;
        }
        #title-card .date-text {
            font-size: 28px;
            color: #5a3d2b;
            max-width: 80%;
            margin: 0 auto;
            word-wrap: break-word;
            white-space: pre-wrap;
            line-height: 1.3;
            text-align: center;
        }
        
        #destination-card {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Special Elite', 'Courier New', monospace;
            color: #3d2817;
            background: rgba(244, 232, 208, 0.95);
            padding: 30px 50px;
            border: 4px solid #8B4513;
            box-shadow: 5px 5px 20px rgba(0,0,0,0.5);
            z-index: 2000;
            text-align: center;
            opacity: 0;
            transition: opacity 1s;
        }
        #destination-card .destination-text {
            font-size: 36px;
            font-weight: bold;
            letter-spacing: 2px;
        }
        
        /* Location labels */
        .location-label {
            font-family: 'Special Elite', 'Courier New', monospace;
            font-size: 15px;
            color: #3d2817;
            background: rgba(244, 232, 208, 0.95);
            padding: 8px 12px;
            border: 2px solid #8B4513;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.4);
            white-space: nowrap;
            font-weight: bold;
            letter-spacing: 0.5px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Motorcycle icon */
        #motorcycle {
            width: 60px;
            height: 60px;
            position: absolute;
            z-index: 999;
            filter: drop-shadow(4px 4px 6px rgba(0,0,0,0.7));
            pointer-events: none;
            background-image: url('icons/bike.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        /* Person icon */
        #person {
            width: 40px;
            height: 40px;
            position: absolute;
            z-index: 999;
            filter: drop-shadow(4px 4px 6px rgba(0,0,0,0.7));
            pointer-events: none;
            background-image: url('icons/person.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        /* Car icon - faces right (opposite direction to bike) */
        #car {
            width: 60px;
            height: 60px;
            position: absolute;
            z-index: 999;
            filter: drop-shadow(4px 4px 6px rgba(0,0,0,0.7));
            pointer-events: none;
            background-image: url('icons/car.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        /* Backpacker icon */
        #backpacker {
            width: 35px;
            height: 35px;
            position: absolute;
            z-index: 999;
            filter: drop-shadow(4px 4px 6px rgba(0,0,0,0.7));
            pointer-events: none;
            background-image: url('icons/backpack.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Special+Elite&display=swap" rel="stylesheet">
</head>
<body>
    <div id="map"></div>
    <div id="parchment-overlay"></div>
    <div id="title-card"></div>
    <div id="destination-card"><div class="destination-text"></div></div>
    <div id="compass">
        <svg viewBox="0 0 200 200">
            <!-- Decorative outer circles -->
            <circle cx="100" cy="100" r="98" fill="none" stroke="#3d2817" stroke-width="2"/>
            <circle cx="100" cy="100" r="90" fill="#f4e8d0" stroke="#8B4513" stroke-width="3"/>
            <circle cx="100" cy="100" r="82" fill="none" stroke="#8B4513" stroke-width="1.5" stroke-dasharray="5,3"/>
            
            <!-- Cardinal direction markers -->
            <line x1="100" y1="12" x2="100" y2="30" stroke="#8B0000" stroke-width="4" stroke-linecap="round"/>
            <line x1="100" y1="170" x2="100" y2="188" stroke="#3d2817" stroke-width="3" stroke-linecap="round"/>
            <line x1="12" y1="100" x2="30" y2="100" stroke="#3d2817" stroke-width="3" stroke-linecap="round"/>
            <line x1="170" y1="100" x2="188" y2="100" stroke="#3d2817" stroke-width="3" stroke-linecap="round"/>
            
            <!-- Ordinal markers (smaller) -->
            <line x1="32" y1="32" x2="42" y2="42" stroke="#666" stroke-width="2"/>
            <line x1="168" y1="32" x2="158" y2="42" stroke="#666" stroke-width="2"/>
            <line x1="32" y1="168" x2="42" y2="158" stroke="#666" stroke-width="2"/>
            <line x1="168" y1="168" x2="158" y2="158" stroke="#666" stroke-width="2"/>
            
            <!-- Cardinal directions text -->
            <text x="100" y="25" text-anchor="middle" font-size="32" font-family="serif" font-weight="bold" fill="#8B0000" stroke="#f4e8d0" stroke-width="0.5">N</text>
            <text x="100" y="183" text-anchor="middle" font-size="22" font-family="serif" font-weight="bold" fill="#3d2817">S</text>
            <text x="178" y="107" text-anchor="middle" font-size="22" font-family="serif" font-weight="bold" fill="#3d2817">E</text>
            <text x="22" y="107" text-anchor="middle" font-size="22" font-family="serif" font-weight="bold" fill="#3d2817">W</text>
            
            <!-- Ordinal directions text -->
            <text x="150" y="55" text-anchor="middle" font-size="14" font-family="serif" fill="#666">NE</text>
            <text x="150" y="155" text-anchor="middle" font-size="14" font-family="serif" fill="#666">SE</text>
            <text x="50" y="155" text-anchor="middle" font-size="14" font-family="serif" fill="#666">SW</text>
            <text x="50" y="55" text-anchor="middle" font-size="14" font-family="serif" fill="#666">NW</text>
            
            <!-- Decorative star/compass points -->
            <polygon points="100,18 103,35 100,32 97,35" fill="#8B0000" stroke="#3d2817" stroke-width="1"/>
            <polygon points="100,182 97,165 100,168 103,165" fill="#d4c5a9" stroke="#3d2817" stroke-width="1"/>
            
            <!-- Center ornament -->
            <circle cx="100" cy="100" r="12" fill="#3d2817" stroke="#8B4513" stroke-width="2"/>
            <circle cx="100" cy="100" r="6" fill="#f4e8d0"/>
            <circle cx="100" cy="100" r="3" fill="#8B4513"/>
        </svg>
    </div>
    <div id="date-stamp"></div>
    <div id="motorcycle" style="display:none;"></div>
    <div id="person" style="display:none;"></div>
    <div id="car" style="display:none;"></div>
    <div id="backpacker" style="display:none;"></div>
    
    <script>
        // Initialize map
        let map;
        let animatedLine;
        let startMarker, endMarker;
        let allMarkers = []; // Track all markers for cleanup
        let allLines = [];   // Track all lines for cleanup
        
        function initMap(routeSegments, options = {}) {
            const {
                zoom = 11,
                lineColor = '#8B4513',
                lineWidth = 3,
                animationDuration = 5000,
                useSmoothing = true,
                finalDestination = 'DESTINATION',
                title = 'ADVENTURE',
                date = '',
                tileLayer = null
            } = options;
            
            // Clean up existing map if present (for re-initialization)
            if (map) {
                // Remove all markers
                allMarkers.forEach(m => m.remove());
                allMarkers = [];
                
                // Remove all lines
                allLines.forEach(l => l.remove());
                allLines = [];
                
                // Remove the map itself
                map.remove();
                map = null;
            }
            
            // Reset UI elements
            const titleCard = document.getElementById('title-card');
            const destinationCard = document.getElementById('destination-card');
            if (titleCard) titleCard.style.opacity = '0';
            if (destinationCard) destinationCard.style.opacity = '0';
            
            // Flatten all coordinates for bounds calculation
            const allCoordinates = routeSegments.flatMap(seg => seg.coordinates);
            
            // Calculate center point
            const centerLat = (allCoordinates[0][0] + allCoordinates[allCoordinates.length - 1][0]) / 2;
            const centerLng = (allCoordinates[0][1] + allCoordinates[allCoordinates.length - 1][1]) / 2;
            
            // Create map
            map = L.map('map', {
                zoomControl: false,
                attributionControl: false,
                zoomAnimation: true,
                fadeAnimation: true
            }).setView([centerLat, centerLng], zoom);
            
            // Add tile layer (use provided or default to OSM)
            if (tileLayer && tileLayer.url) {
                L.tileLayer(tileLayer.url, tileLayer.options || {}).addTo(map);
            } else {
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 18,
                    attribution: '© OpenStreetMap contributors'
                }).addTo(map);
            }
            
            // Fit bounds to show entire route centered
            const bounds = L.latLngBounds(allCoordinates.map(c => [c[0], c[1]]));
            map.fitBounds(bounds, { padding: [50, 50] });
            
            // Force center the map on the route center
            const center = bounds.getCenter();
            map.setView(center, map.getZoom());
            
            // Store for animation
            window.mapData = {
                routeSegments,
                lineColor,
                lineWidth,
                animationDuration,
                useSmoothing,
                finalDestination,
                title,
                date,
                maxZoom: tileLayer?.options?.maxZoom || 18
            };
        }
        
        async function animateRoute() {
            const { routeSegments, lineColor, lineWidth, animationDuration, useSmoothing, finalDestination, title, date, maxZoom } = window.mapData;
            
            // Flatten all coordinates
            const allCoordinates = routeSegments.flatMap(seg => seg.coordinates);
            
            // STAGE 1: Show title card with date
            const titleCard = document.getElementById('title-card');
            titleCard.innerHTML = `<div class="title-text">${title}</div><div class="date-text">${date}</div>`;
            titleCard.style.opacity = '1';
            
            await new Promise(resolve => setTimeout(resolve, 2500));
            
            // Fade out title card
            titleCard.style.opacity = '0';
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Show title stamp in corner (smaller version)
            const dateStamp = document.getElementById('date-stamp');
            dateStamp.textContent = title.toUpperCase();
            dateStamp.style.opacity = '1';
            
            // STAGE 2: Pan and zoom to starting point
            const startCoord = allCoordinates[0];
            const endCoord = allCoordinates[allCoordinates.length - 1];
            
            // First show overview of entire route
            const routeBounds = L.latLngBounds(allCoordinates);
            map.fitBounds(routeBounds, { padding: [50, 50], animate: false });
            
            // Add start marker and label IMMEDIATELY (visible during pan)
            startMarker = L.circleMarker(allCoordinates[0], {
                radius: 10,
                fillColor: '#8B0000',
                color: '#3d2817',
                weight: 3,
                fillOpacity: 0.9
            }).addTo(map);
            
            // Add start label (visible immediately)
            const startLabel = L.marker(allCoordinates[0], {
                icon: L.divIcon({
                    className: 'location-label',
                    html: routeSegments[0].fromLabel,
                    iconSize: [160, 30],
                    iconAnchor: [80, -20]
                })
            }).addTo(map);
            
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Calculate zoom levels BEFORE flyTo so we can use the correct starting zoom
            const bounds = L.latLngBounds(allCoordinates);
            const overviewZoom = map.getBoundsZoom(bounds, false, [80, 80]);
            const defaultCloseZoom = Math.min(14, maxZoom);
            
            // Build array of zoom levels for each segment
            const segmentZoomLevels = routeSegments.map((seg, idx) => {
                let zoom;
                if (seg.zoomLevel !== null && seg.zoomLevel !== undefined) {
                    zoom = seg.zoomLevel;
                } else {
                    const segBounds = L.latLngBounds(seg.coordinates);
                    const autoZoom = map.getBoundsZoom(segBounds, false, [100, 100]);
                    zoom = Math.max(autoZoom, overviewZoom);
                }
                return Math.min(zoom, maxZoom);
            });
            
            const startZoom = segmentZoomLevels[0] || defaultCloseZoom;
            
            // Then smoothly pan and zoom to starting point using the CORRECT zoom level
            map.flyTo(startCoord, startZoom, { duration: 2 });
            
            await new Promise(resolve => setTimeout(resolve, 2500));
            
            // Add end marker (hidden)
            endMarker = L.circleMarker(allCoordinates[allCoordinates.length - 1], {
                radius: 10,
                fillColor: '#006400',
                color: '#3d2817',
                weight: 3,
                fillOpacity: 0
            }).addTo(map);
            
            // Add end label (initially hidden)
            const endLabel = L.marker(allCoordinates[allCoordinates.length - 1], {
                icon: L.divIcon({
                    className: 'location-label',
                    html: finalDestination,
                    iconSize: [260, 30],
                    iconAnchor: [130, -20]
                }),
                opacity: 0
            }).addTo(map);
            
            window.endLabel = endLabel;
            
            // Show icons (initially hidden)
            const motorcycle = document.getElementById('motorcycle');
            const person = document.getElementById('person');
            const car = document.getElementById('car');
            const backpacker = document.getElementById('backpacker');
            motorcycle.style.display = 'block';
            person.style.display = 'block';
            car.style.display = 'block';
            backpacker.style.display = 'block';
            motorcycle.style.opacity = '1'; // Show motorcycle initially
            
            // STAGE 3: Animate route WITH simultaneous zoom
            // (segmentZoomLevels already calculated above before flyTo)
            const endZoom = segmentZoomLevels[segmentZoomLevels.length - 1] || defaultCloseZoom;

            const startTime = performance.now();
            let animatedLine = null;
            let lastAngle = 0;
            
            // Initialize camera state from ACTUAL current map position/zoom
            // This ensures no jump at animation start
            const currentMapCenter = map.getCenter();
            let cameraLat = currentMapCenter.lat;
            let cameraLng = currentMapCenter.lng;
            let cameraZoom = map.getZoom();  // Use actual map zoom, not calculated
            
            // Pre-create all waypoint markers and labels (hidden) for fade-in effect
            const waypointMarkers = [];
            const waypointLabels = [];
            const waypointShown = [];
            
            // Calculate cumulative distances for each segment endpoint
            const segmentEndpoints = [];
            let cumulativeWaypoints = 0;
            for (let i = 0; i < routeSegments.length; i++) {
                cumulativeWaypoints += routeSegments[i].coordinates.length;
                const endCoord = routeSegments[i].coordinates[routeSegments[i].coordinates.length - 1];
                segmentEndpoints.push({
                    coord: endCoord,
                    waypointIndex: cumulativeWaypoints - 1,
                    label: routeSegments[i].toLabel,
                    showMarker: routeSegments[i].showMarker !== false
                });
                
                // Create hidden marker and label for each waypoint (except last - that's the destination)
                if (i < routeSegments.length - 1 && routeSegments[i].toLabel) {
                    const marker = L.circleMarker(endCoord, {
                        radius: 10,
                        fillColor: '#FF8C00',
                        color: '#3d2817',
                        weight: 3,
                        fillOpacity: 0
                    }).addTo(map);
                    
                    const label = L.marker(endCoord, {
                        icon: L.divIcon({
                            className: 'location-label',
                            html: routeSegments[i].toLabel,
                            iconSize: [200, 30],
                            iconAnchor: [100, -20]
                        }),
                        opacity: 0
                    }).addTo(map);
                    
                    waypointMarkers.push(marker);
                    waypointLabels.push(label);
                    waypointShown.push(false);
                }
            }
            
            // Calculate segment durations based on their lengths
            const segmentLengths = routeSegments.map(seg => seg.coordinates.length);
            const totalLength = segmentLengths.reduce((a, b) => a + b, 0);
            const segmentDurations = segmentLengths.map(len => (len / totalLength) * animationDuration);
            const segmentProgressThresholds = [];
            let cumulativeProgress = 0;
            for (let i = 0; i < segmentDurations.length; i++) {
                cumulativeProgress += segmentDurations[i] / animationDuration;
                segmentProgressThresholds.push(cumulativeProgress);
            }
            
            // Build zoom keyframes based on OVERALL progress (not per-segment)
            // Create keyframes that transition BETWEEN segments for smooth zoom
            // Each segment's zoom level applies at its MIDPOINT, with smooth transitions before/after
            const zoomKeyframes = [];
            
            // Start: begin at first segment's zoom
            zoomKeyframes.push({ progress: 0, zoom: segmentZoomLevels[0] });
            
            // For each segment, the zoom reaches its target at the segment's midpoint
            let prevThreshold = 0;
            for (let i = 0; i < segmentProgressThresholds.length; i++) {
                const segmentMidpoint = (prevThreshold + segmentProgressThresholds[i]) / 2;
                zoomKeyframes.push({ 
                    progress: segmentMidpoint, 
                    zoom: segmentZoomLevels[i]
                });
                prevThreshold = segmentProgressThresholds[i];
            }
            
            // End: finish at last segment's zoom
            zoomKeyframes.push({ progress: 1, zoom: segmentZoomLevels[segmentZoomLevels.length - 1] });
            
            // Wrap animation in a Promise
            await new Promise((animationResolve) => {
                function drawFrame(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / animationDuration, 1);
                    
                    // Determine which segment we're on
                    let currentSegment = routeSegments.length - 1; // Default to last segment
                    let segmentStartProgress = 0;
                    for (let i = 0; i < segmentProgressThresholds.length; i++) {
                        if (progress < segmentProgressThresholds[i]) {
                            currentSegment = i;
                            break;
                        }
                        segmentStartProgress = segmentProgressThresholds[i];
                    }
                    
                    // Calculate progress within current segment
                    const segmentEndProgress = segmentProgressThresholds[currentSegment] || 1;
                    const segmentDuration = segmentEndProgress - segmentStartProgress;
                    const segmentProgress = segmentDuration > 0 ? Math.min((progress - segmentStartProgress) / segmentDuration, 1) : 1;
                    
                    // Fade in waypoint labels when 1/3 of distance away
                    // Fade out waypoint labels after we've left that segment
                    for (let i = 0; i < waypointMarkers.length; i++) {
                        // Calculate when to show this waypoint (when we're 1/3 into its segment)
                        const showThreshold = i === 0 
                            ? segmentProgressThresholds[0] * 0.33 
                            : segmentProgressThresholds[i] - (segmentProgressThresholds[i] - (segmentProgressThresholds[i-1] || 0)) * 0.67;
                        
                        // Calculate when to hide this waypoint (when we're 1/3 into the NEXT segment)
                        const hideThreshold = i < segmentProgressThresholds.length - 1
                            ? segmentProgressThresholds[i] + (segmentProgressThresholds[i + 1] - segmentProgressThresholds[i]) * 0.33
                            : 2; // Never hide the last waypoint before destination
                        
                        if (progress >= showThreshold && progress < hideThreshold) {
                            // Show the waypoint
                            if (!waypointShown[i]) {
                                waypointMarkers[i].setStyle({ fillOpacity: 0.9 });
                                waypointLabels[i].setOpacity(1);
                                waypointShown[i] = true;
                            }
                        } else if (progress >= hideThreshold && waypointShown[i]) {
                            // Fade out the waypoint
                            waypointMarkers[i].setStyle({ fillOpacity: 0 });
                            waypointLabels[i].setOpacity(0);
                            waypointShown[i] = false;
                        }
                    }
                    
                    // Handle icon visibility and fading
                    const currentIconType = routeSegments[currentSegment].icon;
                    let currentIcon;
                    
                    // Hide all icons first
                    motorcycle.style.opacity = '0';
                    person.style.opacity = '0';
                    car.style.opacity = '0';
                    backpacker.style.opacity = '0';
                    
                    // Show current icon
                    if (currentIconType === 'bike') {
                        currentIcon = motorcycle;
                        motorcycle.style.opacity = '1';
                    } else if (currentIconType === 'car') {
                        currentIcon = car;
                        car.style.opacity = '1';
                    } else if (currentIconType === 'backpacker') {
                        currentIcon = backpacker;
                        backpacker.style.opacity = '1';
                    } else {
                        // Default to person
                        currentIcon = person;
                        person.style.opacity = '1';
                    }
                    
                    // Safety check for coordinates
                    if (!routeSegments[currentSegment] || !routeSegments[currentSegment].coordinates) {
                        console.error('Missing coordinates for segment', currentSegment);
                        animationResolve();
                        return;
                    }
                    
                    const coordinates = routeSegments[currentSegment].coordinates;
                    
                    // Use linear speed for consistent movement (no acceleration/deceleration)
                    const eased = segmentProgress;
                    
                    // === SMOOTH ZOOM using keyframes based on overall progress ===
                    // Find the two keyframes we're between
                    let prevKeyframe = zoomKeyframes[0];
                    let nextKeyframe = zoomKeyframes[zoomKeyframes.length - 1];
                    for (let i = 0; i < zoomKeyframes.length - 1; i++) {
                        if (progress >= zoomKeyframes[i].progress && progress < zoomKeyframes[i + 1].progress) {
                            prevKeyframe = zoomKeyframes[i];
                            nextKeyframe = zoomKeyframes[i + 1];
                            break;
                        }
                    }
                    
                    // Interpolate between keyframes using smoothstep
                    const keyframeRange = nextKeyframe.progress - prevKeyframe.progress;
                    const keyframeT = keyframeRange > 0 ? (progress - prevKeyframe.progress) / keyframeRange : 0;
                    const smoothT = keyframeT * keyframeT * (3 - 2 * keyframeT); // smoothstep
                    const targetZoom = prevKeyframe.zoom + (nextKeyframe.zoom - prevKeyframe.zoom) * smoothT;
                    
                    // Calculate vehicle position within segment
                    const totalPoints = coordinates.length - 1;
                    const currentFloat = eased * totalPoints;
                    const currentIndex = Math.floor(currentFloat);
                    const fraction = currentFloat - currentIndex;
                    
                    // Get vehicle position with interpolation
                    const safeIndex = Math.max(0, Math.min(currentIndex, coordinates.length - 1));
                    const safeNextIndex = Math.min(safeIndex + 1, coordinates.length - 1);
                    
                    let vehiclePos;
                    if (safeIndex < coordinates.length - 1 && fraction > 0) {
                        const current = coordinates[safeIndex];
                        const next = coordinates[safeNextIndex];
                        vehiclePos = [
                            current[0] + (next[0] - current[0]) * fraction,
                            current[1] + (next[1] - current[1]) * fraction
                        ];
                    } else {
                        vehiclePos = coordinates[safeIndex];
                    }
                    
                    // === CINEMATIC CAMERA: Look ahead of vehicle ===
                    const lookAheadDistance = Math.min(40, coordinates.length - safeIndex - 1);
                    const lookAheadIndex = Math.min(safeIndex + lookAheadDistance, coordinates.length - 1);
                    const lookAheadPos = coordinates[lookAheadIndex];
                    
                    // Blend between vehicle position and look-ahead (more ahead when zoomed out)
                    // Calculate how "zoomed out" we are relative to a close-up view
                    const zoomOutFactor = Math.max(0, (16 - targetZoom) / 6); // 0 at zoom 16, 1 at zoom 10
                    const lookAheadBlend = 0.25 * zoomOutFactor;
                    const targetLat = vehiclePos[0] + (lookAheadPos[0] - vehiclePos[0]) * lookAheadBlend;
                    const targetLng = vehiclePos[1] + (lookAheadPos[1] - vehiclePos[1]) * lookAheadBlend;
                    
                    // Smooth camera POSITION tracking (lower = smoother but more lag)
                    const positionSmoothing = 0.08;
                    
                    cameraLat += (targetLat - cameraLat) * positionSmoothing;
                    cameraLng += (targetLng - cameraLng) * positionSmoothing;
                    
                    // Smooth zoom tracking - very low value for gradual, cinematic zoom changes
                    // Combined with keyframe interpolation, this creates buttery smooth zoom
                    const zoomSmoothing = 0.03;
                    cameraZoom += (targetZoom - cameraZoom) * zoomSmoothing;
                    
                    // Set camera - smooth position and smooth zoom
                    map.setView([cameraLat, cameraLng], cameraZoom, { animate: false });
                    
                    // Get visible coordinates for line drawing
                    const visibleCoords = coordinates.slice(0, safeIndex + 1);
                    if (safeIndex < coordinates.length - 1 && fraction > 0) {
                        visibleCoords.push([
                            coordinates[safeIndex][0] + (coordinates[safeNextIndex][0] - coordinates[safeIndex][0]) * fraction,
                            coordinates[safeIndex][1] + (coordinates[safeNextIndex][1] - coordinates[safeIndex][1]) * fraction
                        ]);
                    }
                    
                    // Remove old line
                    if (animatedLine) {
                        map.removeLayer(animatedLine);
                    }
                    
                    // Build complete line including all previous segments
                    let allVisibleCoords = [];
                    for (let i = 0; i < currentSegment; i++) {
                        allVisibleCoords.push(...routeSegments[i].coordinates);
                    }
                    allVisibleCoords.push(...visibleCoords);
                    
                    // Draw new line (dashed for vintage look)
                    if (allVisibleCoords.length > 1) {
                        animatedLine = L.polyline(allVisibleCoords, {
                            color: lineColor,
                            weight: lineWidth,
                            opacity: 0.9,
                            smoothFactor: 1,
                            dashArray: '10, 8'
                        }).addTo(map);
                    }
                    
                    // Update icon position with smooth rotation
                    if (visibleCoords.length > 0) {
                        const currentPos = visibleCoords[visibleCoords.length - 1];
                        const point = map.latLngToContainerPoint(currentPos);
                        
                        // Center the icon on the point (adjust for icon size)
                        let iconSize;
                        if (currentIconType === 'bike' || currentIconType === 'car') {
                            iconSize = 60;
                        } else if (currentIconType === 'backpacker') {
                            iconSize = 35;
                        } else {
                            iconSize = 40; // person
                        }
                        const iconOffset = iconSize / 2;
                        currentIcon.style.left = (point.x - iconOffset) + 'px';
                        currentIcon.style.top = (point.y - iconOffset) + 'px';
                        
                        // =====================================================
                        // ICON ORIENTATION LOGIC
                        // =====================================================
                        // Icon default orientations at rotate(0deg):
                        //   - car.png: faces RIGHT → (hood on right)
                        //   - bike.png: faces RIGHT → (handlebars on right)
                        //   - backpack.png: stands upright (flip horizontally)
                        //   - person.png: stands upright (flip horizontally)
                        // =====================================================
                        
                        // Use MEDIUM lookahead for stable but responsive tilt
                        // Too short = jittery, too long = doesn't follow curves
                        const tiltLookAhead = Math.min(coordinates.length - 1, safeIndex + 25);
                        const tiltFromPos = coordinates[safeIndex];
                        const tiltToPos = coordinates[tiltLookAhead];
                        
                        // Convert to screen coordinates for tilt
                        const tiltFromPoint = map.latLngToContainerPoint(tiltFromPos);
                        const tiltToPoint = map.latLngToContainerPoint(tiltToPos);
                        
                        // Calculate direction vector
                        const dx = tiltToPoint.x - tiltFromPoint.x;  // positive = moving right
                        const dy = tiltToPoint.y - tiltFromPoint.y;  // positive = moving down
                        
                        // atan2 gives: 0°=right, 90°=down, ±180°=left, -90°=up
                        const dynamicAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                        
                        if (currentIconType === 'car' || currentIconType === 'bike') {
                            // CAR and BIKE face RIGHT at rotate(0deg)
                            // Use angle for road-following tilt
                            // - Travel EAST (0°): need 0° - already facing right
                            // - Travel SOUTH (90°): need 90° rotation
                            // - Travel WEST (180°): need 180° rotation
                            // - Travel NORTH (-90°): need -90° rotation
                            
                            let targetAngle = dynamicAngle;
                            
                            // Normalize to -180 to 180 range
                            while (targetAngle > 180) targetAngle -= 360;
                            while (targetAngle < -180) targetAngle += 360;
                            
                            // Very smooth interpolation to prevent flickering
                            // Lower value = smoother but more lag
                            const smoothingFactor = 0.06;
                            let angleDiff = targetAngle - lastAngle;
                            
                            // Handle wrap-around at ±180°
                            while (angleDiff > 180) angleDiff -= 360;
                            while (angleDiff < -180) angleDiff += 360;
                            
                            // Only update if change is significant (ignore tiny fluctuations)
                            if (Math.abs(angleDiff) > 1) {
                                lastAngle = lastAngle + angleDiff * smoothingFactor;
                            }
                            
                            // Normalize lastAngle to prevent drift
                            while (lastAngle > 180) lastAngle -= 360;
                            while (lastAngle < -180) lastAngle += 360;
                            
                            currentIcon.style.transform = `rotate(${lastAngle}deg)`;
                            currentIcon.style.transformOrigin = 'center center';
                            
                        } else {
                            // PERSON and BACKPACKER - stay upright, flip horizontally
                            // Use longer lookahead for flip direction (more stable)
                            const flipLookAhead = Math.min(coordinates.length - 1, safeIndex + 30);
                            const flipToPos = coordinates[flipLookAhead];
                            const flipToPoint = map.latLngToContainerPoint(flipToPos);
                            const flipDx = flipToPoint.x - tiltFromPoint.x;
                            const travelingLeft = flipDx < 0;
                            
                            if (currentIconType === 'backpacker') {
                                // Backpacker faces LEFT by default, flip when going RIGHT
                                currentIcon.style.transform = travelingLeft ? 'scaleX(1)' : 'scaleX(-1)';
                            } else {
                                // Person faces RIGHT by default, flip when going LEFT
                                currentIcon.style.transform = travelingLeft ? 'scaleX(-1)' : 'scaleX(1)';
                            }
                            currentIcon.style.transformOrigin = 'center center';
                        }
                    }
                    
                    // Show end marker when complete
                    if (progress >= 0.98) {
                        endMarker.setStyle({ fillOpacity: 0.9 });
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(drawFrame);
                    } else {
                        // Show destination label with animation after arrival
                        endMarker.setStyle({ fillOpacity: 0.9 });
                        setTimeout(() => {
                            if (window.endLabel) {
                                window.endLabel.setOpacity(1);
                            }
                            setTimeout(() => animationResolve(), 1000);
                        }, 500);
                    }
                }
                
                requestAnimationFrame(drawFrame);
            });
        }
        
        // Make functions available globally
        window.initMap = initMap;
        window.animateRoute = animateRoute;
    </script>
</body>
</html>
