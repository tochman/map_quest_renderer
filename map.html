<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map Animation</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Special Elite', 'Courier New', monospace;
            overflow: hidden;
        }
        #map {
            width: 100%;
            height: 100vh;
            position: relative;
        }
        .leaflet-container {
            background: #e8dcc7;
            /* Vintage map styling */
            filter: sepia(0.4) saturate(0.6) contrast(1.15) brightness(1.05);
        }
        
        /* Make map tiles look aged */
        .leaflet-tile {
            filter: contrast(0.95) brightness(1.1);
            opacity: 0.95 !important;
        }
        
        /* Parchment texture overlay */
        #parchment-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(139, 90, 43, 0.03) 2px, rgba(139, 90, 43, 0.03) 4px),
                repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(139, 90, 43, 0.03) 2px, rgba(139, 90, 43, 0.03) 4px);
            background-color: rgba(244, 232, 208, 0.4);
            pointer-events: none;
            z-index: 1000;
            mix-blend-mode: multiply;
        }
        
        /* Compass rose */
        #compass {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 100px;
            height: 100px;
            z-index: 1001;
            opacity: 0.9;
            filter: drop-shadow(4px 4px 8px rgba(0,0,0,0.4));
        }
        
        /* Date stamp */
        #date-stamp {
            position: absolute;
            top: 30px;
            left: 30px;
            font-family: 'Special Elite', 'Courier New', monospace;
            font-size: 24px;
            color: #3d2817;
            background: rgba(244, 232, 208, 0.9);
            padding: 15px 25px;
            border: 3px solid #8B4513;
            box-shadow: 3px 3px 10px rgba(0,0,0,0.3);
            z-index: 1001;
            transform: rotate(-2deg);
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        /* Centered title card */
        #title-card {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Special Elite', 'Courier New', monospace;
            color: #3d2817;
            background: rgba(244, 232, 208, 0.95);
            padding: 40px 60px;
            border: 4px solid #8B4513;
            box-shadow: 5px 5px 20px rgba(0,0,0,0.5);
            z-index: 2000;
            text-align: center;
            opacity: 0;
            transition: opacity 1s;
            max-width: 800px;
        }
        #title-card .title-text {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 15px;
            line-height: 1.2;
        }
        #title-card .date-text {
            font-size: 28px;
            color: #5a3d2b;
            max-width: 80%;
            margin: 0 auto;
            word-wrap: break-word;
            white-space: pre-wrap;
            line-height: 1.3;
            text-align: center;
        }
        
        #destination-card {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Special Elite', 'Courier New', monospace;
            color: #3d2817;
            background: rgba(244, 232, 208, 0.95);
            padding: 30px 50px;
            border: 4px solid #8B4513;
            box-shadow: 5px 5px 20px rgba(0,0,0,0.5);
            z-index: 2000;
            text-align: center;
            opacity: 0;
            transition: opacity 1s;
        }
        #destination-card .destination-text {
            font-size: 36px;
            font-weight: bold;
            letter-spacing: 2px;
        }
        
        /* Location labels */
        .location-label {
            font-family: 'Special Elite', 'Courier New', monospace;
            font-size: 15px;
            color: #3d2817;
            background: rgba(244, 232, 208, 0.95);
            padding: 8px 12px;
            border: 2px solid #8B4513;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.4);
            white-space: nowrap;
            font-weight: bold;
            letter-spacing: 0.5px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Motorcycle icon */
        #motorcycle {
            width: 60px;
            height: 60px;
            position: absolute;
            z-index: 999;
            filter: drop-shadow(4px 4px 6px rgba(0,0,0,0.7));
            pointer-events: none;
            background-image: url('icons/bike.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        /* Person icon */
        #person {
            width: 40px;
            height: 40px;
            position: absolute;
            z-index: 999;
            filter: drop-shadow(4px 4px 6px rgba(0,0,0,0.7));
            pointer-events: none;
            background-image: url('icons/person.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        /* Car icon - faces right (opposite direction to bike) */
        #car {
            width: 60px;
            height: 60px;
            position: absolute;
            z-index: 999;
            filter: drop-shadow(4px 4px 6px rgba(0,0,0,0.7));
            pointer-events: none;
            background-image: url('icons/car.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        /* Backpacker icon */
        #backpacker {
            width: 35px;
            height: 35px;
            position: absolute;
            z-index: 999;
            filter: drop-shadow(4px 4px 6px rgba(0,0,0,0.7));
            pointer-events: none;
            background-image: url('icons/backpack.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Special+Elite&display=swap" rel="stylesheet">
</head>
<body>
    <div id="map"></div>
    <div id="parchment-overlay"></div>
    <div id="title-card"></div>
    <div id="destination-card"><div class="destination-text"></div></div>
    <div id="compass">
        <svg viewBox="0 0 200 200">
            <!-- Decorative outer circles -->
            <circle cx="100" cy="100" r="98" fill="none" stroke="#3d2817" stroke-width="2"/>
            <circle cx="100" cy="100" r="90" fill="#f4e8d0" stroke="#8B4513" stroke-width="3"/>
            <circle cx="100" cy="100" r="82" fill="none" stroke="#8B4513" stroke-width="1.5" stroke-dasharray="5,3"/>
            
            <!-- Cardinal direction markers -->
            <line x1="100" y1="12" x2="100" y2="30" stroke="#8B0000" stroke-width="4" stroke-linecap="round"/>
            <line x1="100" y1="170" x2="100" y2="188" stroke="#3d2817" stroke-width="3" stroke-linecap="round"/>
            <line x1="12" y1="100" x2="30" y2="100" stroke="#3d2817" stroke-width="3" stroke-linecap="round"/>
            <line x1="170" y1="100" x2="188" y2="100" stroke="#3d2817" stroke-width="3" stroke-linecap="round"/>
            
            <!-- Ordinal markers (smaller) -->
            <line x1="32" y1="32" x2="42" y2="42" stroke="#666" stroke-width="2"/>
            <line x1="168" y1="32" x2="158" y2="42" stroke="#666" stroke-width="2"/>
            <line x1="32" y1="168" x2="42" y2="158" stroke="#666" stroke-width="2"/>
            <line x1="168" y1="168" x2="158" y2="158" stroke="#666" stroke-width="2"/>
            
            <!-- Cardinal directions text -->
            <text x="100" y="25" text-anchor="middle" font-size="32" font-family="serif" font-weight="bold" fill="#8B0000" stroke="#f4e8d0" stroke-width="0.5">N</text>
            <text x="100" y="183" text-anchor="middle" font-size="22" font-family="serif" font-weight="bold" fill="#3d2817">S</text>
            <text x="178" y="107" text-anchor="middle" font-size="22" font-family="serif" font-weight="bold" fill="#3d2817">E</text>
            <text x="22" y="107" text-anchor="middle" font-size="22" font-family="serif" font-weight="bold" fill="#3d2817">W</text>
            
            <!-- Ordinal directions text -->
            <text x="150" y="55" text-anchor="middle" font-size="14" font-family="serif" fill="#666">NE</text>
            <text x="150" y="155" text-anchor="middle" font-size="14" font-family="serif" fill="#666">SE</text>
            <text x="50" y="155" text-anchor="middle" font-size="14" font-family="serif" fill="#666">SW</text>
            <text x="50" y="55" text-anchor="middle" font-size="14" font-family="serif" fill="#666">NW</text>
            
            <!-- Decorative star/compass points -->
            <polygon points="100,18 103,35 100,32 97,35" fill="#8B0000" stroke="#3d2817" stroke-width="1"/>
            <polygon points="100,182 97,165 100,168 103,165" fill="#d4c5a9" stroke="#3d2817" stroke-width="1"/>
            
            <!-- Center ornament -->
            <circle cx="100" cy="100" r="12" fill="#3d2817" stroke="#8B4513" stroke-width="2"/>
            <circle cx="100" cy="100" r="6" fill="#f4e8d0"/>
            <circle cx="100" cy="100" r="3" fill="#8B4513"/>
        </svg>
    </div>
    <div id="date-stamp"></div>
    <div id="motorcycle" style="display:none;"></div>
    <div id="person" style="display:none;"></div>
    <div id="car" style="display:none;"></div>
    <div id="backpacker" style="display:none;"></div>
    
    <script>
        // Initialize map
        let map;
        let animatedLine;
        let startMarker, endMarker;
        let allMarkers = []; // Track all markers for cleanup
        let allLines = [];   // Track all lines for cleanup
        
        function initMap(routeSegments, options = {}) {
            const {
                zoom = 11,
                lineColor = '#8B4513',
                lineWidth = 3,
                animationDuration = 5000,
                useSmoothing = true,
                finalDestination = 'DESTINATION',
                title = 'ADVENTURE',
                date = ''
            } = options;
            
            // Clean up existing map if present (for re-initialization)
            if (map) {
                // Remove all markers
                allMarkers.forEach(m => m.remove());
                allMarkers = [];
                
                // Remove all lines
                allLines.forEach(l => l.remove());
                allLines = [];
                
                // Remove the map itself
                map.remove();
                map = null;
            }
            
            // Reset UI elements
            const titleCard = document.getElementById('title-card');
            const destinationCard = document.getElementById('destination-card');
            if (titleCard) titleCard.style.opacity = '0';
            if (destinationCard) destinationCard.style.opacity = '0';
            
            // Flatten all coordinates for bounds calculation
            const allCoordinates = routeSegments.flatMap(seg => seg.coordinates);
            
            // Calculate center point
            const centerLat = (allCoordinates[0][0] + allCoordinates[allCoordinates.length - 1][0]) / 2;
            const centerLng = (allCoordinates[0][1] + allCoordinates[allCoordinates.length - 1][1]) / 2;
            
            // Create map
            map = L.map('map', {
                zoomControl: false,
                attributionControl: false,
                zoomAnimation: true,
                fadeAnimation: true
            }).setView([centerLat, centerLng], zoom);
            
            // Add reliable OpenStreetMap tile layer (we'll style it vintage with CSS)
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 18,
                attribution: '&copy; OpenStreetMap contributors'
            }).addTo(map);
            
            // Fit bounds to show entire route centered
            const bounds = L.latLngBounds(allCoordinates.map(c => [c[0], c[1]]));
            map.fitBounds(bounds, { padding: [50, 50] });
            
            // Force center the map on the route center
            const center = bounds.getCenter();
            map.setView(center, map.getZoom());
            
            // Store for animation
            window.mapData = {
                routeSegments,
                lineColor,
                lineWidth,
                animationDuration,
                useSmoothing,
                finalDestination,
                title,
                date
            };
        }
        
        async function animateRoute() {
            const { routeSegments, lineColor, lineWidth, animationDuration, useSmoothing, finalDestination, title, date } = window.mapData;
            
            // Flatten all coordinates
            const allCoordinates = routeSegments.flatMap(seg => seg.coordinates);
            
            // STAGE 1: Show title card with date
            const titleCard = document.getElementById('title-card');
            titleCard.innerHTML = `<div class="title-text">${title}</div><div class="date-text">${date}</div>`;
            titleCard.style.opacity = '1';
            
            await new Promise(resolve => setTimeout(resolve, 2500));
            
            // Fade out title card
            titleCard.style.opacity = '0';
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Show title stamp in corner (smaller version)
            const dateStamp = document.getElementById('date-stamp');
            dateStamp.textContent = title.toUpperCase();
            dateStamp.style.opacity = '1';
            
            // STAGE 2: Pan and zoom to starting point
            const startCoord = allCoordinates[0];
            const endCoord = allCoordinates[allCoordinates.length - 1];
            
            // First show overview of entire route
            const routeBounds = L.latLngBounds(allCoordinates);
            map.fitBounds(routeBounds, { padding: [50, 50], animate: false });
            
            // Add start marker and label IMMEDIATELY (visible during pan)
            startMarker = L.circleMarker(allCoordinates[0], {
                radius: 10,
                fillColor: '#8B0000',
                color: '#3d2817',
                weight: 3,
                fillOpacity: 0.9
            }).addTo(map);
            
            // Add start label (visible immediately)
            const startLabel = L.marker(allCoordinates[0], {
                icon: L.divIcon({
                    className: 'location-label',
                    html: routeSegments[0].fromLabel,
                    iconSize: [160, 30],
                    iconAnchor: [80, -20]
                })
            }).addTo(map);
            
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Then smoothly pan and zoom to starting point
            map.flyTo(startCoord, 14, { duration: 2 });
            
            await new Promise(resolve => setTimeout(resolve, 2500));
            
            // Add end marker (hidden)
            endMarker = L.circleMarker(allCoordinates[allCoordinates.length - 1], {
                radius: 10,
                fillColor: '#006400',
                color: '#3d2817',
                weight: 3,
                fillOpacity: 0
            }).addTo(map);
            
            // Add end label (initially hidden)
            const endLabel = L.marker(allCoordinates[allCoordinates.length - 1], {
                icon: L.divIcon({
                    className: 'location-label',
                    html: finalDestination,
                    iconSize: [260, 30],
                    iconAnchor: [130, -20]
                }),
                opacity: 0
            }).addTo(map);
            
            window.endLabel = endLabel;
            
            // Show icons (initially hidden)
            const motorcycle = document.getElementById('motorcycle');
            const person = document.getElementById('person');
            const car = document.getElementById('car');
            const backpacker = document.getElementById('backpacker');
            motorcycle.style.display = 'block';
            person.style.display = 'block';
            car.style.display = 'block';
            backpacker.style.display = 'block';
            motorcycle.style.opacity = '1'; // Show motorcycle initially
            
            // STAGE 3: Animate route WITH simultaneous zoom
            // Calculate zoom levels for smooth transition
            const bounds = L.latLngBounds(allCoordinates);
            const startZoom = 13;  // Start closer
            const midZoom = map.getBoundsZoom(bounds, false, [80, 80]);
            const endZoom = 14;    // End close up

            const startTime = performance.now();
            let animatedLine = null;
            let lastAngle = 0;
            let lastZoom = startZoom; // Track last zoom for smooth interpolation
            
            // Pre-create all waypoint markers and labels (hidden) for fade-in effect
            const waypointMarkers = [];
            const waypointLabels = [];
            const waypointShown = [];
            
            // Calculate cumulative distances for each segment endpoint
            const segmentEndpoints = [];
            let cumulativeWaypoints = 0;
            for (let i = 0; i < routeSegments.length; i++) {
                cumulativeWaypoints += routeSegments[i].coordinates.length;
                const endCoord = routeSegments[i].coordinates[routeSegments[i].coordinates.length - 1];
                segmentEndpoints.push({
                    coord: endCoord,
                    waypointIndex: cumulativeWaypoints - 1,
                    label: routeSegments[i].toLabel,
                    showMarker: routeSegments[i].showMarker !== false
                });
                
                // Create hidden marker and label for each waypoint (except last - that's the destination)
                if (i < routeSegments.length - 1 && routeSegments[i].toLabel) {
                    const marker = L.circleMarker(endCoord, {
                        radius: 10,
                        fillColor: '#FF8C00',
                        color: '#3d2817',
                        weight: 3,
                        fillOpacity: 0
                    }).addTo(map);
                    
                    const label = L.marker(endCoord, {
                        icon: L.divIcon({
                            className: 'location-label',
                            html: routeSegments[i].toLabel,
                            iconSize: [200, 30],
                            iconAnchor: [100, -20]
                        }),
                        opacity: 0
                    }).addTo(map);
                    
                    waypointMarkers.push(marker);
                    waypointLabels.push(label);
                    waypointShown.push(false);
                }
            }
            
            // Calculate segment durations based on their lengths
            const segmentLengths = routeSegments.map(seg => seg.coordinates.length);
            const totalLength = segmentLengths.reduce((a, b) => a + b, 0);
            const segmentDurations = segmentLengths.map(len => (len / totalLength) * animationDuration);
            const segmentProgressThresholds = [];
            let cumulativeProgress = 0;
            for (let i = 0; i < segmentDurations.length; i++) {
                cumulativeProgress += segmentDurations[i] / animationDuration;
                segmentProgressThresholds.push(cumulativeProgress);
            }
            
            // Wrap animation in a Promise
            await new Promise((animationResolve) => {
                function drawFrame(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / animationDuration, 1);
                    
                    // Determine which segment we're on
                    let currentSegment = routeSegments.length - 1; // Default to last segment
                    let segmentStartProgress = 0;
                    for (let i = 0; i < segmentProgressThresholds.length; i++) {
                        if (progress < segmentProgressThresholds[i]) {
                            currentSegment = i;
                            break;
                        }
                        segmentStartProgress = segmentProgressThresholds[i];
                    }
                    
                    // Calculate progress within current segment
                    const segmentEndProgress = segmentProgressThresholds[currentSegment] || 1;
                    const segmentDuration = segmentEndProgress - segmentStartProgress;
                    const segmentProgress = segmentDuration > 0 ? Math.min((progress - segmentStartProgress) / segmentDuration, 1) : 1;
                    
                    // Fade in waypoint labels when 1/3 of distance away
                    for (let i = 0; i < waypointMarkers.length; i++) {
                        if (!waypointShown[i]) {
                            // Calculate when to show this waypoint (when we're 1/3 into its segment)
                            const showThreshold = i === 0 
                                ? segmentProgressThresholds[0] * 0.33 
                                : segmentProgressThresholds[i] - (segmentProgressThresholds[i] - (segmentProgressThresholds[i-1] || 0)) * 0.67;
                            
                            if (progress >= showThreshold) {
                                waypointMarkers[i].setStyle({ fillOpacity: 0.9 });
                                waypointLabels[i].setOpacity(1);
                                waypointShown[i] = true;
                            }
                        }
                    }
                    
                    // Handle icon visibility and fading
                    const currentIconType = routeSegments[currentSegment].icon;
                    let currentIcon;
                    
                    // Hide all icons first
                    motorcycle.style.opacity = '0';
                    person.style.opacity = '0';
                    car.style.opacity = '0';
                    backpacker.style.opacity = '0';
                    
                    // Show current icon
                    if (currentIconType === 'bike') {
                        currentIcon = motorcycle;
                        motorcycle.style.opacity = '1';
                    } else if (currentIconType === 'car') {
                        currentIcon = car;
                        car.style.opacity = '1';
                    } else if (currentIconType === 'backpacker') {
                        currentIcon = backpacker;
                        backpacker.style.opacity = '1';
                    } else {
                        // Default to person
                        currentIcon = person;
                        person.style.opacity = '1';
                    }
                    
                    // Safety check for coordinates
                    if (!routeSegments[currentSegment] || !routeSegments[currentSegment].coordinates) {
                        console.error('Missing coordinates for segment', currentSegment);
                        animationResolve();
                        return;
                    }
                    
                    const coordinates = routeSegments[currentSegment].coordinates;
                    
                    // Use linear speed for consistent movement (no acceleration/deceleration)
                    const eased = segmentProgress;
                    
                    // Smooth continuous zoom using sine curve
                    // Creates a gentle arc: start zoomed in -> zoom out to middle -> zoom back in at end
                    // Using sine gives perfectly smooth acceleration/deceleration
                    const zoomCurve = Math.sin(progress * Math.PI); // 0 -> 1 -> 0 (smooth bell curve)
                    const targetZoom = startZoom - (startZoom - midZoom) * zoomCurve;
                    
                    // Faster zoom interpolation for responsive feel
                    const currentZoom = lastZoom + (targetZoom - lastZoom) * 0.12;
                    lastZoom = currentZoom;
                    
                    // Calculate camera center based on progress within segment
                    const totalPoints = coordinates.length - 1;
                    const currentFloat = eased * totalPoints;
                    const currentIndex = Math.floor(currentFloat);
                    const fraction = currentFloat - currentIndex;
                    
                    // Get current position on route
                    let cameraCenter;
                    const safeIndex = Math.max(0, Math.min(currentIndex, coordinates.length - 1));
                    const safeNextIndex = Math.min(safeIndex + 1, coordinates.length - 1);
                    
                    if (safeIndex < coordinates.length - 1 && fraction > 0) {
                        const current = coordinates[safeIndex];
                        const next = coordinates[safeNextIndex];
                        cameraCenter = [
                            current[0] + (next[0] - current[0]) * fraction,
                            current[1] + (next[1] - current[1]) * fraction
                        ];
                    } else {
                        cameraCenter = coordinates[safeIndex];
                    }
                    
                    // Smoothly pan and zoom camera
                    map.setView(cameraCenter, currentZoom, { animate: false });
                    
                    // Get visible coordinates for line drawing
                    const visibleCoords = coordinates.slice(0, safeIndex + 1);
                    if (safeIndex < coordinates.length - 1 && fraction > 0) {
                        visibleCoords.push([
                            coordinates[safeIndex][0] + (coordinates[safeNextIndex][0] - coordinates[safeIndex][0]) * fraction,
                            coordinates[safeIndex][1] + (coordinates[safeNextIndex][1] - coordinates[safeIndex][1]) * fraction
                        ]);
                    }
                    
                    // Remove old line
                    if (animatedLine) {
                        map.removeLayer(animatedLine);
                    }
                    
                    // Build complete line including all previous segments
                    let allVisibleCoords = [];
                    for (let i = 0; i < currentSegment; i++) {
                        allVisibleCoords.push(...routeSegments[i].coordinates);
                    }
                    allVisibleCoords.push(...visibleCoords);
                    
                    // Draw new line (dashed for vintage look)
                    if (allVisibleCoords.length > 1) {
                        animatedLine = L.polyline(allVisibleCoords, {
                            color: lineColor,
                            weight: lineWidth,
                            opacity: 0.9,
                            smoothFactor: 1,
                            dashArray: '10, 8'
                        }).addTo(map);
                    }
                    
                    // Update icon position with smooth rotation
                    if (visibleCoords.length > 0) {
                        const currentPos = visibleCoords[visibleCoords.length - 1];
                        const point = map.latLngToContainerPoint(currentPos);
                        
                        // Center the icon on the point (adjust for icon size)
                        let iconSize;
                        if (currentIconType === 'bike' || currentIconType === 'car') {
                            iconSize = 60;
                        } else if (currentIconType === 'backpacker') {
                            iconSize = 35;
                        } else {
                            iconSize = 40; // person
                        }
                        const iconOffset = iconSize / 2;
                        currentIcon.style.left = (point.x - iconOffset) + 'px';
                        currentIcon.style.top = (point.y - iconOffset) + 'px';
                        
                        // Rotate icons based on direction (only bike and car rotate - person and backpacker stay upright)
                        if (currentIconType === 'bike' || currentIconType === 'car') {
                            // Look far ahead for stable direction (50+ waypoints ahead)
                            const lookAhead = Math.min(coordinates.length - 1, safeIndex + 50);
                            const fromPos = coordinates[safeIndex];
                            const toPos = coordinates[lookAhead];
                            
                            // Convert to screen coordinates
                            const fromPoint = map.latLngToContainerPoint(fromPos);
                            const toPoint = map.latLngToContainerPoint(toPos);
                            
                            // Calculate direction in screen space
                            const dx = toPoint.x - fromPoint.x;
                            const dy = toPoint.y - fromPoint.y;
                            
                            // Only update if there's significant movement (higher threshold)
                            if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
                                // Calculate target angle
                                // bike faces LEFT (add 180Â°), car faces RIGHT (no offset)
                                const angleOffset = (currentIconType === 'car') ? 0 : 180;
                                let targetAngle = Math.atan2(dy, dx) * 180 / Math.PI + angleOffset;
                                
                                // Normalize to -180 to 180
                                while (targetAngle > 180) targetAngle -= 360;
                                while (targetAngle < -180) targetAngle += 360;
                                
                                // Only apply if angle change is significant (> 5 degrees)
                                let angleDiff = targetAngle - lastAngle;
                                while (angleDiff > 180) angleDiff -= 360;
                                while (angleDiff < -180) angleDiff += 360;
                                
                                if (Math.abs(angleDiff) > 5) {
                                    // Very slow interpolation for smooth cinematic feel
                                    lastAngle = lastAngle + angleDiff * 0.05;
                                }
                                
                                currentIcon.style.transform = `rotate(${lastAngle}deg)`;
                                currentIcon.style.transformOrigin = `${iconOffset}px ${iconOffset}px`;
                            }
                        } else {
                            // Person and backpacker stay upright - no rotation
                            currentIcon.style.transform = 'rotate(0deg)';
                        }
                    }
                    
                    // Show end marker when complete
                    if (progress >= 0.98) {
                        endMarker.setStyle({ fillOpacity: 0.9 });
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(drawFrame);
                    } else {
                        // Show destination label with animation after arrival
                        endMarker.setStyle({ fillOpacity: 0.9 });
                        setTimeout(() => {
                            if (window.endLabel) {
                                window.endLabel.setOpacity(1);
                            }
                            setTimeout(() => animationResolve(), 1000);
                        }, 500);
                    }
                }
                
                requestAnimationFrame(drawFrame);
            });
        }
        
        // Make functions available globally
        window.initMap = initMap;
        window.animateRoute = animateRoute;
    </script>
</body>
</html>
